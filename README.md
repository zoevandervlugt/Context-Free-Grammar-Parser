# Context-Free-Grammar-Parser [Document Link](https://docs.google.com/document/d/1NzWoRt5bRfIU2RMqYrBLgnyAt2gfWIe5aHU6L1U8qQk/edit?usp=sharing)
## Objectives
- Practice the procedure for converting a context-free grammar into Chomsky normal form
- Write and parse structured text files
- Choose (or create) the optimal data structures to represent certain kinds of data and facilitate computation
- Utilize the technique of dynamic programming to design efficient algorithms
- Write exhaustive test cases to confirm that both a grammar and program are correct
- Comment and document code as clearly as possible for other users
- Debug, debug, debug!

## Requirements
- Can be in **any** language! And any number of files!
- Must run from command line, even if written in an IDE
- README file explaining how to run our code
  - What programming language will Arjun need to use?
  - How will he run the program?
  - Act like he's never seen the code before and is unfamiliar with the project
- Don't use package statements if coding in Java
- DON'T USE EXTERNAL LIBRARIES
  - Only base language. Can import, but must be part of base language.
- Thoroughly comment code
  - Purpose of loops
  - Purpose of conditional logic
  - Explain purpose of manipulating variable, if not obvious
  - If making custom classes, data types, or methods, comment appropriately
  - You'll lose points for under- or over- commenting
  - Indicate where and how Sipser algorithm is implemented
    - **Need to have comments that match all comments in Sipser's pseudocode**
- Use good style
  - Proper indentation
  - Appropriate space around all operators
  - Variable, class, and method/function names should be as descriptive as possible
- Project Report
- **Submit these files on Moodle**
```
  CNF-Conversions.pdf 
  anbnGrammar.txt 
  palindromeGrammar.txt 
  equalAsBsGrammar.txt
  anbnGrammarInput.txt 
  palindromeGrammarInput.txt 
  equalAsBsGrammarInput.txt
  All of your source code files
  README.md 
  Your project report as a PDF
```

## Tasks
### 1. Parse and test membership in the a^* grammar.
Write a program that does the following:
- It should take two command line arguments. The first argument denotes the name of the file containing the description of the grammar. The second argument denotes the name of the file containing the input strings that we want to feed into the grammar.
- The program should be able to read and “parse” the grammar; what I mean by this is that it should be able to identify what the variables, terminals, rules, and start variable of the grammar are. Your program should print out all of this info (see below for the format of this output).
- The program should go through each string in the second file and print out whether that string is generated by the grammar. It should use the algorithm described in Sipser to do this. If you use any other algorithm/approach to test membership, you will not receive any credit.
### 2. Convert grammars to CNF
&nbsp;Here are some examples of context-free languages that we studied in class, as well as the context-free grammars that can be used to generate the languages. 
| Language                                     | Grammar                        |
| --------                                     | -------                        |
| L = {a^nb^n such that n >= 0}                |  X → aXb OR e                   |
| L = {w such that w is a palindrome}          |  X → aXb OR bXa OR a OR b OR e     |
| L = {w such that w has equal a's and b's}    |  X → aXb OR bXa OR XX OR e        |

Note that X is the start variable in each grammar. \
**Convert these grammars into Chomsky Normal Form.** For credit, you must use the procedure described above (and in Sipser). You must show all of the steps in your derivation of the CNF version of the grammar. You will not get any credit if you simply submit the final CNF versions of the grammar (even if your CNF grammar is correct). \
**Put each of your three conversions into a document called ```CNF-Conversions.pdf```.**
### 3. Test our CNF grammars
For each of the three CNF grammars that you derived in task 2, create a text file describing your grammar. Your text file should be in the same format as the grammar file that I provided to you at the start of the project. Put your grammar descriptions into the following files:
```
  anbnGrammar.txt 
  palindromeGrammar.txt 
  equalAsBsGrammar.txt
``` 
Additionally, create an input file to feed to each grammar. Your input files should have the following names:
```
  anbnGrammarInput.txt 
  palindromeGrammarInput.txt 
  equalAsBsGrammarInput.txt
```
Each of your input files should include 10 strings that are part of the language, and 10 strings that are not part of the language. Try to include tricky edge cases that test the robustness of your code.

Run your grammar parser from task 1 on each of your three grammars. Verify that you get the correct results. If you didn’t get the correct results, then you will have to decide whether your grammar is incorrect, or whether your parser is incorrect!

